// WILHELM Daniel YAMAN Kendal
        -:    0:Source:kv.c
        -:    0:Graph:kv.gcno
        -:    0:Data:kv.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <unistd.h>
        -:    4:#include <sys/stat.h>
        -:    5:#include <fcntl.h>
        -:    6:#include <string.h>
        -:    7:#include "kv.h"
        -:    8:#include <errno.h>
        -:    9:
        -:   10:#define LG_EN_TETE_H 5 // MagicN + index_f_hache
        -:   11:#define LG_EN_TETE_BLK 5 // MagicN + nb_bloc
        -:   12:#define LG_EN_TETE_KV 1 // MagicN
        -:   13:#define LG_EN_TETE_DKV 5// MagicN + nb_blocs
        -:   14:#define LG_EN_TETE_BLOC 9 //bloc suivant(char)+nr bloc suivant(int) + nb emplacements (int)
        -:   15:
        -:   16:typedef struct KV
        -:   17:{
        -:   18:	int descr_h;
        -:   19:	int descr_blk;
        -:   20:	int descr_kv;
        -:   21:	int descr_dkv;
        -:   22:    alloc_t methode_alloc;
        -:   23:    unsigned char * dkv;
        -:   24:    len_t remplissement_dkv;
        -:   25:    len_t longueur_dkv;
        -:   26:    const char * mode;
        -:   27:    int couple_nr_kv_next;
        -:   28:    int (*f_hachage)(const kv_datum* kdatum);
        -:   29:    unsigned char *bloc;
        -:   30:    int key_long;
        -:   31:    int * tabbloc;
        -:   32:    int longueur_buf_bloc;
        -:   33:    int nb_blocs;
        -:   34:}KV ;
        -:   35:
        -:   36:KV *kv_open (const char *dbname, const char *mode, int hidx, alloc_t alloc);
        -:   37:int kv_close (KV *kv);
        -:   38:int kv_get (KV *kv, const kv_datum *key, kv_datum *val);
        -:   39:int kv_put (KV *kv, const kv_datum *key, const kv_datum *val) ;
        -:   40:int kv_del (KV *kv, const kv_datum *key) ;
        -:   41:void kv_start (KV *kv) ;
        -:   42:int kv_next (KV *kv, kv_datum *key, kv_datum *val) ;
        -:   43:
        -:   44:// Fonctions générales
        -:   45:int read_controle(int descripteur,void * ptr,int nboctets);
        -:   46:int write_controle(int descripteur,const void * ptr,int nboctets);
        -:   47:
        -:   48:// Fonctions d'allocation
        -:   49:int first_fit (KV * kv,const kv_datum* key, const kv_datum *val);
        -:   50:int best_fit(KV * kv,const kv_datum* key, const kv_datum *val);
        -:   51:int worst_fit (KV * kv,const kv_datum* key, const kv_datum *val);
        -:   52:
        -:   53:// Fonctions de hachage 
        -:   54:int (*choix_hachage(int index))(const kv_datum *clef);
        -:   55:int hachage_defaut(const kv_datum *clef);
        -:   56:int hachage_test(const kv_datum *clef);
        -:   57:int  djb_hash(const kv_datum* clef);
        -:   58:int fnv_hash(const kv_datum* clef);
        -:   59:
        -:   60:// Modification
        -:   61:unsigned char * modif(unsigned char * buf,int i,int debut);
        -:   62:int absolue(int val);
        -:   63:
        -:   64:// Accès à dkv
        -:   65:len_t access_offset_dkv(int emplacement,KV* kv);
        -:   66:int access_lg_dkv(int emplacement,KV* kv);
        -:   67:
        -:   68:// fonctions utilisées dans l'ordre :
        -:   69:char * concat(const char *s1,const char * s2);
        -:   70:int verificationMagicN(int descr,const char *mode,unsigned char nbtest,int test);
        -:   71:int remplit_bloc(int debut,KV*kv);
        -:   72:int RechercheBlocH(KV * kv, int hache);
        -:   73:len_t RechercheOffsetClef(KV *kv,const kv_datum * key,int numbloc);
        -:   74:int compareClefkv(KV *kv,const kv_datum * key,len_t offset);
        -:   75:len_t RechercheTailleClef(KV * kv,len_t offset);
        -:   76:int RemplissageVal(KV *kv,len_t offset,kv_datum *val,const kv_datum * key);
        -:   77:int RemplissageClef(KV *kv,len_t offset, kv_datum *clef);
        -:   78:int Allouebloc(KV * kv);
        -:   79:int liaisonHBlk(KV * kv,int hache, int numbloc);
        -:   80:void insertionFusionEspace(KV* kv,int emplacement_dkv);
        -:   81:void fusionVoisinsVidesSP(int voisins, int emplacement_dkv, int voisinp, KV* kv);
        -:   82:void decaledkv_arriere(KV* kv,int emplacement_a_sup);
        -:   83:void libereEmplacementdkv(len_t offset,KV* kv);
        -:   84:int libereEmplacementblk(int numbloc,len_t offset,KV *kv,int hache,int bloc_p);
        -:   85:int supprimeblocdeh(KV* kv, int hache);
        -:   86:int (*choix_allocation(KV *kv))(KV * kv,const kv_datum* key, const kv_datum *val);
        -:   87:void NouvEmplacementDkv(KV* kv, const kv_datum *key, const kv_datum *val);
        -:   88:KV* dkv_aggrandissement(KV * kv);
        -:   89:unsigned char * copie_tableau(unsigned char * tableau, int longueur);
        -:   90:int lienBlkKv (int numbloc,KV * kv,len_t emplacement_kv);
        -:   91:KV* SetOccupeDkv(KV* kv,int emplacement_dkv);
        -:   92:void insertionNewEspace(KV* kv,int emp_dkv,const kv_datum*key,const kv_datum*val);
        -:   93:void creationNewVoisin(KV* kv,int octets_restants,int empl_dkv,len_t t_couple);
        -:   94:void decaledkv_avant(KV* kv,int emplacement_a_decal);
        -:   95:int truncate_kv(KV* kv);
        -:   96:
        -:   97:
        -:   98:
        -:   99:
        -:  100:/*r : O_RDONLY
        -:  101:r+ : O_CREAT|O_RDWR
        -:  102:w : O_CREAT|O_TRUNC|O_WRONLY
        -:  103:w+ : O_CREAT|O_RDWR
        -:  104:*/
        -:  105://retourne NULL si n'arrive pas à ouvrir la base de donnée
        7:  106:KV *kv_open (const char *dbname, const char *mode, int hidx, alloc_t alloc)
        -:  107:{
        7:  108:	KV * kv=malloc(sizeof(struct KV));
        -:  109:	//test de l'existance de dbname.h pour savoir si on créé la base
        -:  110:	int test_existance;
        7:  111:	char * dbnh=concat(dbname,".h");
        7:  112:	char * dbnblk=concat(dbname,".blk");
        7:  113:	char * dbnkv=concat(dbname,".kv");
        7:  114:	char * dbndkv=concat(dbname,".dkv");
        -:  115:	len_t nb_emplacements_dkv;
        -:  116:	unsigned char* buf_dkv;
        -:  117:	int j;
        -:  118:	int indexbase;
        -:  119:	int (*f_hachage)(const kv_datum* kdatum);
        -:  120:	//Mode ouverture des fichiers
        -:  121:	int flag;
        -:  122:	int i;
        7:  123:	if(strcmp(mode,"r")==0) flag = O_RDONLY;
        7:  124:	if(strcmp(mode,"r+")==0) flag =O_CREAT|O_RDWR;
        -:  125:	// ouverture en RDWR car nécessaire pour pouvoir écrire les données
        7:  126:	if(strcmp(mode,"w")==0) flag=O_CREAT|O_TRUNC|O_RDWR; 
        7:  127:	if(strcmp(mode,"w+")==0) flag=O_CREAT|O_TRUNC|O_RDWR;
        -:  128:    
        7:  129:    if((test_existance=open(dbnh,O_RDONLY,0666))==-1)
        -:  130:    {// si la raison de l'erreur d'ouverture est != de l'inexistance de la base
        -:  131:	 // ou que l'on ouvre une base inexistante en mode "r"	
        4:  132:		if(errno!=ENOENT||strcmp(mode,"r")==0) 
        -:  133:		{
    #####:  134:			free(dbnh);
    #####:  135:			free(dbnblk);
    #####:  136:			free(dbnkv);
    #####:  137:			free(dbndkv);
    #####:  138:			free(kv);
    #####:  139:			return NULL;
        -:  140:		}
        -:  141:	}
        -:  142:	else
        -:  143:	{
        3:  144:	if(test_existance==-1)
    #####:  145:		close(test_existance);
        -:  146:	}
        7:  147:	kv->descr_h=open(dbnh,flag,0666);
        7:  148:	if(kv->descr_h==-1)
        -:  149:	{
    #####:  150:		free(dbnh);
    #####:  151:		free(dbnblk);
    #####:  152:		free(dbnkv);
    #####:  153:		free(dbndkv);
    #####:  154:		free(kv);
    #####:  155:		return NULL;
        -:  156:	}
        7:  157:	free(dbnh);
        -:  158:
        7:  159:	kv->descr_blk=open(dbnblk,flag,0666);
        7:  160:	if(kv->descr_blk==-1)
        -:  161:	{
    #####:  162:		free(dbnblk);
    #####:  163:		free(dbnkv);
    #####:  164:		free(dbndkv);
    #####:  165:		close(kv->descr_h);
    #####:  166:		free(kv);
    #####:  167:		return NULL;
        -:  168:	}
        7:  169:	free(dbnblk);
        -:  170:
        7:  171:	kv->descr_kv=open(dbnkv,flag,0666);
        7:  172:	if(kv->descr_kv==-1)
        -:  173:	{
    #####:  174:		kv_close(kv);
    #####:  175:		free(dbnkv);
    #####:  176:		free(dbndkv);
    #####:  177:		close(kv->descr_h);
    #####:  178:		close(kv->descr_blk);
    #####:  179:		free(kv);
    #####:  180:		return NULL;
        -:  181:	}
        7:  182:	free(dbnkv);
        -:  183:
        7:  184:	kv->descr_dkv=open(dbndkv,flag,0666);
        7:  185:	if(kv->descr_dkv==-1)
        -:  186:	{
    #####:  187:		free(dbndkv);
    #####:  188:		close(kv->descr_h);
    #####:  189:		close(kv->descr_blk);
    #####:  190:		close(kv->descr_kv);
    #####:  191:		free(kv);
    #####:  192:		return NULL;
        -:  193:	}
        7:  194:	free(dbndkv);
        -:  195:
        -:  196:
        -:  197:	// contrôle du magic number dans l'en tête de chaque fichier pour s'assurer
        -:  198:	//qu'on a ouvert le bon fichier + Placement du magic number en en-tête si le fichier est vide
       14:  199:    if(verificationMagicN(kv->descr_h,mode,'1',test_existance)!=1||
       14:  200:       verificationMagicN(kv->descr_blk,mode,'2',test_existance)!=1||
       14:  201:       verificationMagicN(kv->descr_kv,mode,'3',test_existance)!=1||
        7:  202:       verificationMagicN(kv->descr_dkv,mode,'4',test_existance)!=1)
        -:  203:    {
    #####:  204:		close(kv->descr_blk);
    #####:  205:		close(kv->descr_h);
    #####:  206:		close(kv->descr_dkv);
    #####:  207:		close(kv->descr_kv);
    #####:  208:		free(kv);
    #####:  209:		return NULL;
        -:  210:    }
        -:  211:
        -:  212:	// base de donnée n'existe pas ou mode w ou w+	
        7:  213:	if((strcmp(mode,"w")==0)||(strcmp(mode,"w+")==0)||test_existance==-1) 
        -:  214:	{
        -:  215:		// Ajout de la fonction de hachage dans l'en-tête de dbname.h
        4:  216:		write_controle(kv->descr_h,&hidx,4);
        -:  217:		// se place avant la fin de l'en-tête pour écrire 0 mettre le nb d'empla
        -:  218:		//cements de dkv à 0
        4:  219:		if(lseek(kv->descr_dkv,LG_EN_TETE_DKV-4,SEEK_SET)==-1) 
        -:  220:		{
    #####:  221:			kv_close(kv);
    #####:  222:			return NULL; 
        -:  223:		}
        4:  224:		j=0;
        4:  225:		if(write_controle(kv->descr_dkv,&j,4)==-1)
        -:  226:		{
    #####:  227:			kv_close(kv);
    #####:  228:			return NULL;
        -:  229:		}
        -:  230:
        -:  231:		// initialise le nb de blocs dans blk
        4:  232:		if(lseek(kv->descr_blk,1,SEEK_SET)==-1)
        -:  233:		{
    #####:  234:			kv_close(kv);
    #####:  235:			return NULL;
        -:  236:		}
        4:  237:		if(write_controle(kv->descr_blk,&j,4)==-1)
        -:  238:		{
    #####:  239:			kv_close(kv);
    #####:  240:			return NULL;
        -:  241:		}
        -:  242:	}
        -:  243:
        -:  244:	
        -:  245:	
        -:  246:	// se place avant la fin de l'en-tête pour lire le nombre d'emplacements
        7:  247:	if(lseek(kv->descr_dkv,LG_EN_TETE_DKV-4,SEEK_SET)==-1) 
        -:  248:	{
    #####:  249:		close(kv->descr_blk);
    #####:  250:		close(kv->descr_h);
    #####:  251:		close(kv->descr_dkv);
    #####:  252:		close(kv->descr_kv);
    #####:  253:		free(kv);
    #####:  254:		return NULL;
        -:  255:	}
        -:  256:	
        -:  257:	// lecture de dkv en mémoire
        7:  258:	if(read_controle(kv->descr_dkv,&nb_emplacements_dkv,sizeof(int))==-1)
        -:  259:	{
    #####:  260:		close(kv->descr_blk);
    #####:  261:		close(kv->descr_h);
    #####:  262:		close(kv->descr_dkv);
    #####:  263:		close(kv->descr_kv);
    #####:  264:		free(kv);
    #####:  265:		return NULL;
        -:  266:	}
        -:  267:
        -:  268:	// initialise le tableau de bloc
        -:  269:	// lit tous les blocs déjà présents
        7:  270:	if(lseek(kv->descr_blk,1,SEEK_SET)==-1)
        -:  271:	{
    #####:  272:		kv_close(kv);
    #####:  273:		return NULL;
        -:  274:	}
        -:  275:	
        7:  276:	if(read_controle(kv->descr_blk,&kv->nb_blocs,4)==-1)
        -:  277:	{
    #####:  278:		kv_close(kv);
    #####:  279:		return NULL;
        -:  280:	}
        -:  281:
        -:  282:	//ajout de 1000 octets supplémentaires pour ajouter de nouveaux couples
        7:  283:	buf_dkv=malloc(nb_emplacements_dkv*8+1000+4+8);	
        -:  284:	//ajout de 40 places pour ajouter de nouveaux couples
        7:  285:	kv->tabbloc=malloc(sizeof(int)*(40+kv->nb_blocs));
        -:  286:	
        -:  287:	// se déplace en arrière pour également lire le nb d'emplacements   
        7:  288:	if(lseek(kv->descr_dkv,-4,SEEK_CUR)==-1) 
        -:  289:	{
    #####:  290:		kv_close(kv);
    #####:  291:		return NULL;
        -:  292:	}
        7:  293:	if(read_controle(kv->descr_dkv,buf_dkv,nb_emplacements_dkv*8+4)==-1)
        -:  294:	{
    #####:  295:		kv_close(kv);
    #####:  296:		return NULL;
        -:  297:	}
        -:  298:	
        -:  299:	// lit l'index 
        7:  300:	if(lseek(kv->descr_h,1,SEEK_SET)==-1)
        -:  301:	{
    #####:  302:		kv_close(kv);
    #####:  303:		return NULL;
        -:  304:	}
        7:  305:	if(read_controle(kv->descr_h,&indexbase,4)==-1)
        -:  306:	{
    #####:  307:		kv_close(kv);
    #####:  308:		return NULL;
        -:  309:	}
        -:  310:	
        -:  311:	
        7:  312:	f_hachage=choix_hachage(indexbase);
        7:  313:	if(f_hachage==NULL) // vérifie qu'il existe une fonction associée à index
        -:  314:	{
    #####:  315:		errno=EINVAL;
    #####:  316:		return NULL;
        -:  317:	}
        -:  318:	
        -:  319:	
        7:  320:	kv->longueur_buf_bloc=40+kv->nb_blocs;
     6199:  321:	for(i=0;i<40+kv->nb_blocs;i++)
     6192:  322:		kv->tabbloc[i]=0;
        -:  323:	 // fait un read de chaque position pour voir si le bloc est déjà occupé ou non
        -:  324:	 // tabbloc = 0 si vide et 1 si occupé
        7:  325:	if(remplit_bloc(0,kv)==-1)
        -:  326:	{
    #####:  327:		kv_close(kv);
    #####:  328:		return NULL;
        -:  329:	}
        -:  330:
        -:  331:	// On enregistre tout dans KV;
        7:  332:	kv->methode_alloc=alloc;
        7:  333:	kv->dkv=buf_dkv;
        7:  334:	kv->remplissement_dkv=(len_t) nb_emplacements_dkv*8+LG_EN_TETE_DKV-1;
        7:  335:	kv->longueur_dkv=(len_t) (4+nb_emplacements_dkv*8+1000);
        7:  336:	kv->mode=mode;
        7:  337:	kv->f_hachage=f_hachage;
        7:  338:	kv->bloc=NULL;
        7:  339:	return kv;
        -:  340:}
        -:  341:
        -:  342:
        -:  343:// ferme la base de donnée, retourne -1 si échoue, sinon retourne 0
        7:  344:int kv_close (KV *kv)
        -:  345:{
        -:  346:	int test;
        7:  347:	int res=0;
        -:  348:	// fermeture des fichiers
        -:  349:
        7:  350:	if((test=close(kv->descr_h))==-1) 
    #####:  351:		res= -1;	
        -:  352:
        7:  353:	if(truncate_kv(kv)==-1)
    #####:  354:		res=-1;
        7:  355:	if((test=close(kv->descr_kv))==-1)
    #####:  356:		res= -1;
        -:  357:		
        7:  358:	if(strcmp(kv->mode,"r")!=0)
        -:  359:	{
        -:  360:		// écrture de dkv
        6:  361:		if(lseek(kv->descr_dkv,1,SEEK_SET)==-1)
        -:  362:		{
    #####:  363:			free(kv->dkv);
    #####:  364:			free(kv->tabbloc);
    #####:  365:			free(kv);
    #####:  366:			return -1; // évite d'écrire n'importe où
        -:  367:		}
        6:  368:		if(write_controle(kv->descr_dkv,kv->dkv,kv->remplissement_dkv)==-1)
    #####:  369:			return -1;
        -:  370:		
        6:  371:		if(lseek(kv->descr_blk,1,SEEK_SET)==-1)
        -:  372:		{
    #####:  373:			free(kv->dkv);
    #####:  374:			free(kv->tabbloc);
    #####:  375:			free(kv);
    #####:  376:			return -1; // évite d'écrire n'importe où
        -:  377:		}
        -:  378:		//écrit le nombre de blocs
        6:  379:		if(write_controle(kv->descr_blk,&kv->nb_blocs,4)==-1)
    #####:  380:			return -1;
        -:  381:		// met .dkv à la bonne taille : LG_EN_TETE_DKV + nb_emplacements*8
        -:  382:		// pas besoin de fstat vu qu'on a toutes les données
        6:  383:		if(ftruncate(kv->descr_dkv, kv->remplissement_dkv+1)==-1)
        -:  384:		{
    #####:  385:			perror("ftruncate dkv");
    #####:  386:			exit(1);
        -:  387:		}
        -:  388:	}
        -:  389:
        7:  390:	if((test=close(kv->descr_dkv))==-1) 
    #####:  391:		res= -1;
        -:  392:	
        7:  393:	if((test=close(kv->descr_blk))==-1) 
    #####:  394:		res= -1;
        -:  395:	
        7:  396:	free(kv->dkv);
        7:  397:	free(kv->tabbloc);
        7:  398:	free(kv);
        7:  399:	return res;
        -:  400:}
        -:  401:
        -:  402:
        -:  403:// fonction qui recherche la valeur associée a key
        -:  404:// Retour : 1 trouvé, 0 non trouvé, -1 erreur
        5:  405:int kv_get (KV *kv, const kv_datum *key, kv_datum *val)
        -:  406:{
        -:  407:
        -:  408:	int hache;
        -:  409:	int numbloc;
        -:  410:	len_t offset;
        -:  411:	// vérifie que la base a été ouverte avec un mode autorisé
        5:  412:	if(strcmp(kv->mode,"w")==0)
        -:  413:	{
        1:  414:		errno=EACCES;
        1:  415:		return -1; // erreur
        -:  416:	}
        -:  417:	// commence par calculer le hache de la clef
        4:  418:	hache=kv->f_hachage(key);
        -:  419:	
        -:  420:	
        -:  421:	// appel de la fonction qui vérifie s'il y a un bloc qui existe à cette position
        -:  422:	// si la fonction retourne 0 alors il n'y a pas de bloc avec cette valeur
        4:  423:	if((numbloc=RechercheBlocH( kv, hache))==0) 
        -:  424:	{
    #####:  425:		errno=EINVAL;
    #####:  426:		return 0;
        -:  427:	}
        4:  428:	if(numbloc==-1)
        -:  429:	{
    #####:  430:		return -1;
        -:  431:	}
        -:  432:	// recherche de la clef dans .kv, retourne l'offset si trouvé, -1 sinon
        4:  433:	offset=RechercheOffsetClef(kv,key,numbloc);
        4:  434:	if(offset==0)
        -:  435:	{
        1:  436:		free(kv->bloc);
        1:  437:		return 0; 
        -:  438:	}
        -:  439:	else
        3:  440:		offset--; // enlève de nouveau le +1 ajouté dans RechercheOffsetClef
        3:  441:	if(RemplissageVal(kv,offset,val,key)==-1)
        -:  442:	{
    #####:  443:		free(kv->bloc);
    #####:  444:		return -1;
        -:  445:	
        -:  446:	}
        3:  447:	free(kv->bloc);	
        3:  448:	if(val==NULL)
    #####:  449:		return -1;
        3:  450:	return 1;
        -:  451:}
        -:  452:
        -:  453:
    14120:  454:int kv_put (KV *kv, const kv_datum *key, const kv_datum *val) 
        -:  455:{
        -:  456:	int (*f_allocation)(KV * kv,const kv_datum *key,const kv_datum* val);
        -:  457:	int hache;
        -:  458:	int numbloc;
        -:  459:	int emplacement_dkv;
        -:  460:	len_t offset;
        -:  461:	unsigned char * tabwrite;
        -:  462:	unsigned int i;
        -:  463:	unsigned char *tmp;
        -:  464:	int test;
        -:  465:	// vérifie que la base a été ouverte avec un mode autorisé 
    14120:  466:	if(strcmp(kv->mode,"r")==0)
        -:  467:	{
    #####:  468:		errno=EACCES;
    #####:  469:		return -1;
        -:  470:	}
        -:  471:
        -:  472:	// calcul le hache de la clef
    14120:  473:	hache=kv->f_hachage(key);
        -:  474:
        -:  475:	// fonction qui vérifie s'il y a un bloc qui existe à cette position
        -:  476:	// si la fonction retourne 0 alors il n'y a pas de bloc avec cette valeur
        -:  477:	// donc il faut en allouer un 
    14120:  478:	if((numbloc=RechercheBlocH( kv, hache))==0)  
        -:  479:	{
        -:  480:			// alloue un bloc initialisé puis retourne 
        -:  481:			//le numéro de ce bloc (la numéroation débute à 1)
     3189:  482:			numbloc=Allouebloc(kv); 
     3189:  483:			if(numbloc==-1)
    #####:  484:				return -1;
     3189:  485:			if(liaisonHBlk(kv,hache,numbloc)==-1)// liaison entre .h et .blk
    #####:  486:				return -1;
        -:  487:	}
    14120:  488:	if(numbloc==-1)
    #####:  489:		return -1;
        -:  490:	//recherche d'abord si la clef est déjà présente dans la base et la supprime
    14120:  491:	test=RechercheOffsetClef(kv,key,numbloc); 
    14120:  492:	if(test==0&&errno!=EINVAL) // dans ce cas il y a eu une erreur
    #####:  493:		return -1;
    14120:  494:	if(test!=0) // clef déjà présente
        -:  495:	{
        -:  496:		// dans ce cas la clef est déjà contenue dans la base donc on del
      250:  497:		free(kv->bloc);
      250:  498:		kv_del(kv,key);
        -:  499:		// fait les même tests pour refaire le lien si del a supprimé le bloc
      250:  500:		if((numbloc=RechercheBlocH( kv, hache))==0)  
        -:  501:		{
      114:  502:			numbloc=Allouebloc(kv); //realloue un bloc
      114:  503:			if(numbloc==-1)
    #####:  504:				return -1;
      114:  505:			if(liaisonHBlk(kv,hache,numbloc)==-1)// liaison entre .h et .blk
    #####:  506:				return -1;
        -:  507:		}
      250:  508:		if(numbloc==-1)
    #####:  509:			return -1;
        -:  510:	}
        -:  511:
        -:  512:	//choix de la bonne méthode d'allocation dans .kv
    14120:  513:	f_allocation=choix_allocation(kv);
        -:  514:	
        -:  515:	//recherche d'un emplacement pour stocker la valeur
    14120:  516:	if((emplacement_dkv=f_allocation(kv,key,val))==-1)
        -:  517:	{// créé un nouvel emplacement dans dkv
    13852:  518:		NouvEmplacementDkv(kv,key,val);
    13852:  519:		emplacement_dkv=*(int*)(kv->dkv)-1;
        -:  520:	}
        -:  521:	
    14120:  522:	offset=access_offset_dkv(emplacement_dkv,kv);
        -:  523:	// enregistrement de la clef à l'offset
    14120:  524:	if(lseek(kv->descr_kv,LG_EN_TETE_KV+offset,SEEK_SET)==-1)
        -:  525:	{
    #####:  526:		perror("lseek");
    #####:  527:		exit(1);
        -:  528:	}
        -:  529:	// écriture du couple
        -:  530:	// on rentre d'abord tout dans un tableau puis on fait un seul write
    14120:  531:	tabwrite=malloc((4+key->len+4+val->len)*sizeof(unsigned char)); 
    14120:  532:	tabwrite=modif(tabwrite,key->len,0); // écriture de la longueur de clef
    14120:  533:	tmp=(unsigned char*)key->ptr;
   188686:  534:	for(i=0;i<key->len;i++)
   174566:  535:		tabwrite[i+4]=tmp[i]; // copie du contenu de la clef
    14120:  536:	tabwrite=modif(tabwrite,val->len,4+key->len);
    14120:  537:	tmp=(unsigned char*)val->ptr;
   188712:  538:	for(i=0;i<val->len;i++)
   174592:  539:		tabwrite[i+4+key->len+4]=tmp[i]; // copie du contenu de la val
    14120:  540:	if(write_controle(kv->descr_kv,tabwrite,4+key->len+4+val->len)==-1)
        -:  541:	{
    #####:  542:		free(tabwrite);
    #####:  543:		return -1;
        -:  544:	}
    14120:  545:	free(tabwrite);
        -:  546:
        -:  547:	// établissement de la liaison entre .blk et .kv
    14120:  548:	if(lienBlkKv (numbloc,kv,offset)==-1)
    #####:  549:		return -1;
        -:  550:	
        -:  551:	// met l'emplacement en tant que place occupée dans dkv
    14120:  552:	kv=SetOccupeDkv(kv,emplacement_dkv);
        -:  553:	// voit s'il y a encore de la place pour un autre couple et l'insère
    14120:  554:	insertionNewEspace(kv,emplacement_dkv,key,val);
    14120:  555:	return 0;
        -:  556:}
        -:  557:
        -:  558:
     3270:  559:int kv_del (KV *kv, const kv_datum *key) 
        -:  560:{
        -:  561:	int hache;
        -:  562:	int numbloc;
        -:  563:	len_t offset;
        -:  564:	int test;
        -:  565:	// vérifie que la base a été ouverte avec un mode autorisé
     3270:  566:	if(strcmp(kv->mode,"r")==0)
        -:  567:	{
    #####:  568:		errno=EACCES;
    #####:  569:		return -1;
        -:  570:	}	
        -:  571:	
        -:  572:	//calcul du hache
     3270:  573:	hache=kv->f_hachage(key);
        -:  574:
        -:  575:
     3270:  576:	if(lseek(kv->descr_h,LG_EN_TETE_H+hache*4,SEEK_SET)==-1)
    #####:  577:		return -1;
        -:  578:
        -:  579:	//regarde si un bloc est alloué 
     3270:  580:	if((test=read(kv->descr_h,&numbloc,4))==-1)
    #####:  581:		return -1;
        -:  582:
        -:  583:	// si la fonction retourne 0 alors il n'y a pas de bloc avec cette valeur 
     3270:  584:	if(test==0||numbloc==0)  
        -:  585:	{
      128:  586:		errno=ENOENT;
      128:  587:		return -1;
        -:  588:	}
        -:  589:
        -:  590:	// lit le bloc
     3142:  591:	kv->bloc=malloc(4096);
     3142:  592:	if(lseek(kv->descr_blk,LG_EN_TETE_BLK+4096*(numbloc-1),SEEK_SET)==-1)
    #####:  593:		return -1;
     3142:  594:	if((read(kv->descr_blk,kv->bloc,4096))==-1)
    #####:  595:		return -1;
        -:  596:
     3142:  597:	offset=RechercheOffsetClef(kv,key,numbloc);
     3142:  598:	if(offset==0&&errno!=EINVAL) // erreur
    #####:  599:		return -1;
     3142:  600:	if(offset==0) // clef non contenue
        -:  601:	{
      163:  602:		errno=ENOENT;
      163:  603:		return -1;
        -:  604:	}
     2979:  605:	offset--; // corrige l'offset renvoyé par RechercheOffsetClef
        -:  606:
        -:  607:	// la clef est contenue dans kv et son offset est offset, on la supprime
     2979:  608:	libereEmplacementdkv(offset,kv);
     2979:  609:	if(libereEmplacementblk(numbloc,offset,kv,hache,0)==-1)
    #####:  610:		return -1;
     2979:  611:	return 0;
        -:  612:}
        1:  613:void kv_start (KV *kv) 
        -:  614:{
        -:  615:	// si mode = w alors pas le droit de lire dans la base
        1:  616:	if(strcmp(kv->mode,"w")==0) 
        -:  617:	{
    #####:  618:		errno=EACCES;
        -:  619:	}
        1:  620:	lseek(kv->descr_kv,LG_EN_TETE_KV,SEEK_SET);
        -:  621:	//initialise le nombre de couple lus de kv à 0
        1:  622:	kv->couple_nr_kv_next=0;
        1:  623:	return ;	
        -:  624:}
        -:  625:
        -:  626:
     5012:  627:int kv_next (KV *kv, kv_datum *key, kv_datum *val) 
        -:  628:{
        -:  629:	len_t offset_couple;
        -:  630:	int longueur;
     5012:  631:	if(strcmp(kv->mode,"w")==0)
        -:  632:	{
    #####:  633:		errno=EACCES;
    #####:  634:		return -1;
        -:  635:	}
    10035:  636:	while(*(int*)kv->dkv-1>=kv->couple_nr_kv_next)
        -:  637:	{
        -:  638:		// balaie le prochain couple de dkv
     5023:  639:		offset_couple=*(int*)(kv->dkv+4+kv->couple_nr_kv_next*8+4);
     5023:  640:		longueur=access_lg_dkv(kv->couple_nr_kv_next,kv);
     5023:  641:		if(longueur>=0) 
        -:  642:		{
       11:  643:			kv->couple_nr_kv_next++;
       11:  644:			continue;
        -:  645:		}
        -:  646:		else
        -:  647:		{
        -:  648:			// remplit d'abord la clef puis recherche la valeur
     5012:  649:			if(RemplissageClef(kv,offset_couple,key)==-1)
        1:  650:				return -1;
     5011:  651:			if(RemplissageVal(kv,offset_couple,val,key)==-1)
    #####:  652:				return -1;
     5011:  653:			kv->couple_nr_kv_next++;
     5011:  654:			return 1;	
        -:  655:		}
        -:  656:	}
    #####:  657:	if(*(int*)kv->dkv==kv->couple_nr_kv_next)
    #####:  658:		return 0;
    #####:  659:	return -1;
        -:  660:}
        -:  661:
        -:  662://************************************FIN************************************//
        -:  663:
        -:  664:
        -:  665:// Fonctions générales de read et write
  5568033:  666:int read_controle(int descripteur,void * ptr,int nboctets)
        -:  667:{
        -:  668:	int test;
  5568033:  669:	if((test=read(descripteur,ptr,nboctets))==-1)
    #####:  670:		return -1;
  5568033:  671:	if(test!=nboctets)
        -:  672:	{
        1:  673:		errno=EINVAL;
        1:  674:		return -1;
        -:  675:	}
  5568032:  676:	return test;
        -:  677:}
    35209:  678:int write_controle(int descripteur,const void * ptr,int nboctets)
        -:  679:{
        -:  680:	int test;
    35209:  681:	if((test=write(descripteur,ptr,nboctets))==-1)
    #####:  682:		return -1;
    35209:  683:	if(test!=nboctets)
        -:  684:	{
    #####:  685:		errno=EINVAL;
    #####:  686:		return -1;
        -:  687:	}
    35209:  688:	return nboctets;
        -:  689:}
        -:  690:
        -:  691:
        -:  692://***********************************************************************************************************//
        -:  693:
        -:  694:// Fonctions d'allocation
        -:  695:// first fit : fonction qui recherche le premier emplacement vide dans .dkv
        -:  696:// s'il n'y a pas d'emplacement vide retourne -1 -> il faudra en allouer un
     9020:  697:int first_fit (KV * kv,const kv_datum* key, const kv_datum *val)
        -:  698:{
     9020:  699:	int nb_emplacements=*(int*)kv->dkv; // nombre d'emplacements
        -:  700:	int i;
     9020:  701:	int taille_emplacement_necessaire = 4 + key->len + 4 + val->len;
        -:  702:	int longueur_emplacement;
        -:  703:	// recherche d'abord s'il peut trouver un bloc assez grand
 20504610:  704:	for(i=0;i<nb_emplacements;i++)
        -:  705:	{
 20495590:  706:		longueur_emplacement=access_lg_dkv(i,kv);
 20495590:  707:		if(longueur_emplacement>0) // emplacement vide
        -:  708:		{
    #####:  709:			if(taille_emplacement_necessaire<=absolue(longueur_emplacement))
    #####:  710:				return i;
        -:  711:		}
        -:  712:	}
        -:  713:	// dans ce cas il n'y a pas d'emplacement vide -> il faut en créer un nouveau
     9020:  714:	return -1;
        -:  715:}
        -:  716:
        -:  717:// worst fit : fonction qui renvoie l'emplacement le plus grand disponible 
        -:  718://ou -1 si pas d'emplacement vide suffisants
      100:  719:int worst_fit (KV * kv, const kv_datum* key, const kv_datum *val)
        -:  720:{
      100:  721:	int nb_emplacements=*(int*)kv->dkv; // nombre d'emplacements
        -:  722:	int i;
      100:  723:	int taille_emplacement_necessaire = 4 + key->len + 4 + val->len;
        -:  724:	int longueur_emplacement;
      100:  725:	int emplacement_plus_grand=-1;
      100:  726:	int longueur_emplacement_plus_grand=-1;
        -:  727:	// recherche le bloc le plus grand
   985100:  728:	for(i=0;i<nb_emplacements;i++)
        -:  729:	{
   985000:  730:		longueur_emplacement=*(int*)(kv->dkv+4+i*8);
   985000:  731:		if(longueur_emplacement>0) // emplacement vide
        -:  732:		{
      100:  733:			if(taille_emplacement_necessaire<=longueur_emplacement
      100:  734:				&&longueur_emplacement>longueur_emplacement_plus_grand)
        -:  735:			{
      100:  736:				longueur_emplacement_plus_grand=longueur_emplacement;
      100:  737:				emplacement_plus_grand=i;
        -:  738:			}
        -:  739:		}
        -:  740:	}
        -:  741:
        -:  742:	// retourne l'emplacement le plus grand.
        -:  743:	//S'il n'y en a pas d'assez grand retourne -1
      100:  744:	return emplacement_plus_grand; 
        -:  745:}
        -:  746:
        -:  747://best fit : fonction qui renvoie l'emplacement le plus petit parmi ceux
        -:  748://pouvant contenir le couple ou -1 s'il n'y en a pas
     5000:  749:int best_fit(KV * kv, const kv_datum* key, const kv_datum *val)
        -:  750:{
     5000:  751:	int nb_emplacements=*(int*)kv->dkv; // nombre d'emplacements
        -:  752:	int i;
     5000:  753:	int taille_emplacement_necessaire = 4 + key->len + 4 + val->len;
        -:  754:	int longueur_emplacement;
     5000:  755:	int emplacement_assez_grand=-1;
        -:  756:	int emplacement;
     5000:  757:	int longueur_emplacement_assez_grand=-1;
     5000:  758:	if(nb_emplacements==0) // aucun emplacement -> il faut en faire un.
    #####:  759:		return -1;
        -:  760:	else // sinon initialise l'emplacement au plus grand possible
        -:  761:	{
 37148866:  762:		for(i=0;i<nb_emplacements;i++)
        -:  763:		{
 37143866:  764:			emplacement=access_lg_dkv(i,kv);
 37143866:  765:			if(emplacement>=0&&longueur_emplacement_assez_grand<emplacement)
        -:  766:			{
      168:  767:				emplacement_assez_grand = i;
      168:  768:				longueur_emplacement_assez_grand = access_lg_dkv(i,kv);
        -:  769:			}
        -:  770:		}
        -:  771:	}
        -:  772:	// recherche le bloc le plus grand
 37148866:  773:	for(i=0;i<nb_emplacements;i++)
        -:  774:	{
 37143866:  775:		longueur_emplacement=access_lg_dkv(i,kv);
 37143866:  776:		if(longueur_emplacement>0) // emplacement vide
        -:  777:		{
      169:  778:			if(taille_emplacement_necessaire<=longueur_emplacement&&
        -:  779:			longueur_emplacement<longueur_emplacement_assez_grand)
        -:  780:			{
    #####:  781:				longueur_emplacement_assez_grand=longueur_emplacement;
    #####:  782:				emplacement_assez_grand=i;
        -:  783:			}
        -:  784:		}
        -:  785:	}
        -:  786:	// retourne l'emplacement plus petit parmi ceux assez grand (ou -1)
     5000:  787:	return emplacement_assez_grand; 
        -:  788:}
        -:  789:
        -:  790:
        -:  791://****************************************************************************//
        -:  792:
        -:  793:// Fonctions de hachage 
        -:  794:
        -:  795:
        -:  796://fonction qui retourne un pointeur sur une fonction de hachage en fonction 
        -:  797://de l'index. Retourne -1 si aucune f de hachage correspond à l'index
        7:  798:int (*choix_hachage(int index))(const kv_datum *clef)
        -:  799:{
        7:  800:	if(index==1)
        1:  801:		return hachage_test; 
        6:  802:	if(index==0)
        4:  803:		return hachage_defaut;
        2:  804:	if(index==2)
        1:  805:		return djb_hash;
        1:  806:	if(index==3)
        1:  807:		return fnv_hash;
    #####:  808:	else return NULL;
        -:  809:}
        -:  810:	
        -:  811:
        -:  812:// Fonction de hachage par défaut
    11854:  813:int hachage_defaut(const kv_datum *clef)
        -:  814:{
    11854:  815:    unsigned char * ptrclef=clef->ptr;
    11854:  816:	unsigned int i,s=0;
   206926:  817:	for(i=0;i<clef->len;i++)
        -:  818:    {
   195072:  819:        s+=ptrclef[i]%999983;
        -:  820:    }
    11854:  821:	return(s);
        -:  822:}
        -:  823:
        -:  824:// hachage de test -> renvoie toujours le même hache ->
        -:  825://test si l'allocation d'un prochain bloc fonctionne -> retourne toujours 0
     5500:  826:int hachage_test(const kv_datum *clef)
        -:  827:{
     5500:  828:	return clef->len%1;	
        -:  829:}
        -:  830:
        -:  831://Bernstein hash
       20:  832:int  djb_hash(const kv_datum* clef)
        -:  833:{
       20:  834:    unsigned int hash = 5381,i;
       20:  835:	unsigned char * ptrclef=(unsigned char *)clef->ptr;
        -:  836:
        -:  837:
       60:  838:	for(i=0;i<clef->len;i++)
        -:  839:    {
       40:  840:        	hash= 33 * hash ^ ptrclef[i];
        -:  841:   	}
       20:  842:	return hash%999983;//modulo pour éviter de dépasser
        -:  843:}
        -:  844:
        -:  845://FNV_hash
       20:  846:int fnv_hash(const kv_datum* clef)
        -:  847:{
       20:  848:    unsigned char *ptrclef=clef->ptr;
       20:  849:    unsigned h = 2166136261;
        -:  850:    unsigned int i;
        -:  851:
       60:  852:    for (i = 0; i < clef->len; i++)
        -:  853:    {
       40:  854:        h = (h * 16777619) ^ ptrclef[i];
        -:  855:    }
        -:  856:
       20:  857:    return h%999983;//modulo pour éviter de dépasser
        -:  858:}
        -:  859:
        -:  860:
        -:  861://****************************************************************************//
        -:  862:
        -:  863:// Modification
        -:  864:
        -:  865:// Fonction qui change le int stocké à partir de début dans buf
 13866523:  866:unsigned char * modif(unsigned char * buf,int i,int debut)
        -:  867:{
 13866523:  868:	buf[debut]=i & 0xFF;
 13866523:  869:	buf[debut+1]=(i>>8) & 0xFF;
 13866523:  870:	buf[debut+2]=(i>>16)& 0xFF;
 13866523:  871:	buf[debut+3]=(i>>24) & 0xFF;
 13866523:  872:	return buf;	
        -:  873:}
        -:  874:
        -:  875:// Fonction qui retourne la valeur absolue de la valeur donnée en paramètre
    40570:  876:int absolue(int val)
        -:  877:{
    40570:  878:	if(val<0) return (val*(-1));
      731:  879:	else return val;
        -:  880:}
        -:  881:
        -:  882:
        -:  883://****************************************************************************//
        -:  884:
        -:  885://Accès à dkv
        -:  886:
        -:  887:
        -:  888:// renvoie la longueur de l'emplacement emplacement
101740062:  889:int access_lg_dkv(int emplacement,KV* kv)
        -:  890:{
101740062:  891:	return (*(int*)(kv->dkv+4+8*emplacement));
        -:  892:}
        -:  893:// renvoie l'offset de l'emplacement emplacement
 14715244:  894:len_t access_offset_dkv(int emplacement,KV* kv)
        -:  895:{
 14715244:  896:	return (*(int*)(kv->dkv+4+8*emplacement+4));
        -:  897:}
        -:  898:
        -:  899://****************************************************************************//
        -:  900:
        -:  901:
        -:  902://fonction qui concatene 2 chaines de caractères
       28:  903:char * concat(const char *s1,const char * s2)
        -:  904:{
        -:  905:	int i,j;
       28:  906:	for(i=0;s1[i]!='\0';i++)
        -:  907:	{}
       28:  908:	char * snew=malloc(i+1+((int)strlen(s2)));
      264:  909:	for(i=0;s1[i]!='\0';i++)
      236:  910:		snew[i]=s1[i];
      119:  911:	for(j=0;s2[j]!='\0';j++)
       91:  912:		snew[i+j]=s2[j];
       28:  913:	snew[i+j]='\0';
       28:  914:	return snew;
        -:  915:}
        -:  916:
        -:  917://fonction qui vérifie que le bon Magic Number se trouve au début 
        -:  918://du fichier descr et  retourne 1 si vérification réussie, 0 sinon
       28:  919:int verificationMagicN(int descr,const char *mode,unsigned char nbtest,int test)
        -:  920:{
        -:  921:        unsigned char buf[1];
       28:  922:    	int test_read=-1;
        -:  923:    	// mode truncate ou base inexistante donc pas besoin
       28:  924:        if(strcmp(mode,"w")==0||strcmp(mode,"w+")==0||test==-1)
       16:  925:            test_read=0;
       28:  926:        if(strcmp(mode,"w")!=0&&strcmp(mode,"w+")!=0&&test!=-1)
        -:  927:		{
       12:  928:			if(read_controle(descr,buf,1)==-1)
    #####:  929:				return-1;
        -:  930:		}
       28:  931:       if(test_read==0)
        -:  932:        {
       16:  933:			buf[0]=nbtest;
       16:  934:			write_controle(descr,buf,1);
        -:  935:         }
        -:  936:        else
        -:  937:        {
       12:  938:			if(buf[0]!=nbtest)
        -:  939:            {
    #####:  940:                return 0;
        -:  941:            }
        -:  942:        }
       28:  943:        return(1);
        -:  944:}
        -:  945:
        -:  946:
        -:  947:// prend comme argument le numéro de bloc (commençant par 1)
        -:  948:// retourne 1 si réussi -1 sinon
       39:  949:int remplit_bloc(int debut,KV*kv)
        -:  950:{
        -:  951:	int i;
        -:  952:	int test;
        -:  953:	char buffbloc[4096];
     9431:  954:	for(i=debut;i<kv->longueur_buf_bloc;i++)
        -:  955:	{
     9392:  956:		if(lseek(kv->descr_blk,LG_EN_TETE_BLK+(i)*4096,SEEK_SET)==-1) 
    #####:  957:			return -1;
     9392:  958:		if((test=read(kv->descr_blk,&buffbloc,4096))==-1)
    #####:  959:			return -1;
        -:  960:
     9392:  961:		if(test==0) // il n'y a aucun bloc
        -:  962:		{
     3440:  963:			kv->tabbloc[i]=0; // indique que le bloc est vide
        -:  964:		}
        -:  965:		else
        -:  966:		{
        -:  967:			// regarde si le nombre d'emplacements est vide
     5952:  968:			if(*(int*)(buffbloc+5)==0)
      510:  969:				kv->tabbloc[i]=0; // indique que le bloc est vide
        -:  970:			else
     5442:  971:				kv->tabbloc[i]=1; // indique que le bloc est occupé
        -:  972:		}
        -:  973:		
        -:  974:	}
       39:  975:	return 1;
        -:  976:} 
        -:  977:
        -:  978:// recherche le numéro de bloc contenu à la position hache du fichier .h
        -:  979:// numéro retourné : numbloc + 1 (vu que les blocs commencent à 1)
        -:  980://en tête bloc : bloc suivant(char)+nr bloc suivant(int) + nb emplacements (int)
        -:  981:// retourne 0 si aucun bloc alloué, -1 s'il y a une erreur, i>0 si bloc trouvé
    14374:  982:int RechercheBlocH(KV * kv, int hache)
        -:  983:{
        -:  984:    int numbloc;
        -:  985:    int test;
        -:  986:	int fils;
        -:  987:	unsigned char * bloctmp;
        -:  988:	
    14374:  989:	if(lseek(kv->descr_h,LG_EN_TETE_H+hache*4,SEEK_SET)==-1)
    #####:  990:		return -1;
        -:  991:
        -:  992:	//regarde si un bloc est alloué 
    14374:  993:	if((test=read(kv->descr_h,&numbloc,4))==-1)
    #####:  994:		return -1;
        -:  995:	
        -:  996:	// soit rien n'était écrit à cet emplacement, soit 0 y était écrit
        -:  997:	// donc il n'y a pas de bloc alloué
    14374:  998:	if(test==0||numbloc==0)
        -:  999:	{
     3303: 1000:		return 0;
        -: 1001:	}
        -: 1002:	else
        -: 1003:	{
        -: 1004:	 // dans ce cas il faut encore regarder si le bloc est vide,
        -: 1005:	 // puis si son fils est vide, etc... Jusqu'à trouver un emplacement vide
    11071: 1006:		kv->bloc=malloc(4096);
        -: 1007:		while(1)
        -: 1008:		{
    16954: 1009:			if(lseek(kv->descr_blk,(numbloc-1)*4096+LG_EN_TETE_BLK,SEEK_SET)==-1)
    #####: 1010:				return -1;
    16954: 1011:			if(read(kv->descr_blk,kv->bloc,4096)==-1)// lit le bloc
    #####: 1012:				return -1;
    16954: 1013:			if(*(int*)(kv->bloc+5)+2<(4096-LG_EN_TETE_BLOC)/4) 
        -: 1014:			{// si le nombre actuel d'emplacements +1 (celui qu'on ajoute) 
        -: 1015:			 // est inférieur au nb max d'emplacements d'un bloc
    11068: 1016:				return numbloc;
        -: 1017:			}
     5886: 1018:			else if(kv->bloc[0]==0) // pas de fils -> en créé un.
        -: 1019:			{
        3: 1020:				bloctmp=kv->bloc; // stock temporairement le père
        3: 1021:				fils=Allouebloc(kv);
        3: 1022:				if(fils==-1)
        -: 1023:				{
    #####: 1024:					free(kv->bloc);
    #####: 1025:					return -1;
        -: 1026:				}
        3: 1027:				bloctmp[0]=1;
        3: 1028:				bloctmp=modif(bloctmp,fils,1); // écrit le fils dans le bloc
        3: 1029:				if(lseek(kv->descr_blk,LG_EN_TETE_BLK+4096*(numbloc-1),
        -: 1030:					SEEK_SET)==-1)
    #####: 1031:					return -1;
        3: 1032:				write_controle(kv->descr_blk,bloctmp,LG_EN_TETE_BLOC+
        3: 1033:				(*(int*)(bloctmp+5))*4);// écrit le bloc
        3: 1034:				free(bloctmp);
        3: 1035:				return fils;
        -: 1036:			}
        -: 1037:			else
        -: 1038:			{
     5883: 1039:				numbloc=*(int*)(kv->bloc+1);
        -: 1040:				
        -: 1041:			}
     5883: 1042:		}
        -: 1043:	}
        -: 1044:}
        -: 1045:
        -: 1046:
        -: 1047:// La numérotation des blocs commence à 1 
        -: 1048:// fonction qui retourne 0 si non trouvé, sinon retourne l'offset de la clef  +1
        -: 1049:// retourne l'offset de la clef, 0 si non trouvée ou erreur
    17267: 1050:len_t RechercheOffsetClef(KV *kv,const kv_datum * key,int numbloc)
        -: 1051:{
    17267: 1052:	unsigned char bool_prochain_bloc=kv->bloc[0];
        -: 1053:	int test;
    17267: 1054:	int i=0;
    17267: 1055:	if(numbloc<0) // on a changé de bloc -> faut mettre à jour
        -: 1056:	{
        1: 1057:		numbloc*=-1;
        -: 1058:		// se place après l'en tête de blk + i bloc
        1: 1059:		if(lseek(kv->descr_blk,LG_EN_TETE_BLK+(numbloc-1)*4096,SEEK_SET)==-1)
    #####: 1060:			return 0;
        1: 1061:		if((test=read(kv->descr_blk,kv->bloc,4096))==-1)
    #####: 1062:			return 0;
        -: 1063:	}
    17267: 1064:	int nb_emplcts_occupes=*(int*)(kv->bloc+5);
  2860292: 1065:	for(i=0;i<nb_emplcts_occupes;i++) 
        -: 1066: 	{// passe tous les emplacements occupés dans le bloc
  2846257: 1067:		test=compareClefkv(kv,key,*(int*)(kv->bloc+LG_EN_TETE_BLOC+4*i));
  2846257: 1068:		if(test==-1)
        -: 1069:		{
    #####: 1070:			errno=EINVAL;	
    #####: 1071:			return 0;
        -: 1072:		}
  2846257: 1073:		if(test==1)
     3232: 1074:			return(*(int*)(kv->bloc+LG_EN_TETE_BLOC+4*i)+1);
        -: 1075:	}
        -: 1076:	// sinon regarde s'il y a un prochain bloc et si oui rappel la fonction
    14035: 1077:	if(bool_prochain_bloc==1)
        1: 1078:		return(RechercheOffsetClef(kv,key,(*(int*)(kv->bloc+1))*(-1) ) );
        -: 1079:	// sinon retourne 0
    14034: 1080:	errno=EINVAL;
    14034: 1081:	return 0;
        -: 1082:}
        -: 1083:
        -: 1084:
        -: 1085://fonction qui retourne 1 si les clefs sont égaux, 0 sinon, -1 si erreur
  2846257: 1086:int compareClefkv(KV *kv,const kv_datum * key,len_t offset)
        -: 1087:{
  2846257: 1088:	len_t longueur=0; // longueur de la clef
  2846257: 1089:	len_t nb_total_lus=0;
  2846257: 1090:	int nb_octets_lus=0;
        -: 1091:	unsigned char buf[2048];
        -: 1092:	unsigned int i;
  2846257: 1093:	unsigned char * ptrkey=key->ptr; // cast le pointeur de key
  2846257: 1094:	unsigned int maxoctetslus=0; // lis au max 512 octets
        -: 1095:	// se déplace d'abord au bonne offset dans .kv
  2846257: 1096:	if(lseek(kv->descr_kv,offset+LG_EN_TETE_KV,SEEK_SET)==-1)
    #####: 1097:		return -1;
        -: 1098:	//lecture de la longueur de la clef -> 4 octets
  2846257: 1099:	if(read_controle(kv->descr_kv,&longueur,4)==-1)
    #####: 1100:		return -1;
  2846257: 1101:	if(longueur!=key->len) // si les longueurs sont différentes 
   144573: 1102:		return 0;
  5406600: 1103:	while(nb_total_lus<longueur) // évite de faire un malloc énorme
        -: 1104:	{// lis au max 2048 octets d'un coup
  2701684: 1105:		maxoctetslus=(longueur-nb_total_lus)%2049;
  2701684: 1106:		nb_octets_lus=read_controle(kv->descr_kv,buf,maxoctetslus); 
  2701684: 1107:		if(nb_octets_lus==-1)
    #####: 1108:			return -1;
  4583737: 1109:		for(i=0;i<maxoctetslus;i++)
        -: 1110:		{
  4580505: 1111:			if(ptrkey[i+nb_total_lus]!=buf[i]) //si 2 octets sont différents
  2698452: 1112:				break; // sort du for
        -: 1113:
        -: 1114:		}
  2701684: 1115:		nb_total_lus+=(len_t)nb_octets_lus;
  2701684: 1116:		if(i<maxoctetslus) 
  2698452: 1117:			break; //si i!=longueur-> 2 octets sont != car for n'a pas terminé
        -: 1118:	}
  2701684: 1119:	if(i==longueur)
        -: 1120:	{
        -: 1121:		// offset
     3232: 1122:		return 1;
        -: 1123:	}
  2698452: 1124:	return 0;
        -: 1125:}
        -: 1126:
        -: 1127:
        -: 1128:
        -: 1129:// retourne la taille de la clef ou 0 si erreur
     5012: 1130:len_t RechercheTailleClef(KV * kv,len_t offset)
        -: 1131:{
        -: 1132:	len_t longueur;
        -: 1133:	//se positionne d'abord à l'offset nécessaire dans le fichier
     5012: 1134:	if(lseek(kv->descr_kv,offset+LG_EN_TETE_KV,SEEK_SET)==-1)
    #####: 1135:		return 0;
     5012: 1136:	if(read_controle(kv->descr_kv,&longueur,4)==-1)//cherche longueur de la clef
    #####: 1137:		return 0;
     5012: 1138:	return(longueur); // retourne la longueur de la valeur
        -: 1139:}
        -: 1140:
        -: 1141:// Remplit la valeur
        -: 1142://retourne 1 si réussi, -1 sinon
     5014: 1143:int RemplissageVal(KV *kv,len_t offset,kv_datum *val,const kv_datum * key)
        -: 1144:{
     5014: 1145:	len_t longueur=key->len;
        -: 1146:	//Vérifie si le pointeur de val est NULL ou si la longueur est déjà définie
     5014: 1147:	if(val==NULL)
        -: 1148:	{
    #####: 1149:		val=malloc(sizeof(struct kv_datum));
    #####: 1150:		val->ptr=NULL;
        -: 1151:	}
     5014: 1152:	if(val->ptr == NULL) // dans ce cas cherche la longueur à allouer
        -: 1153:	{
        -: 1154:		//se positionne d'abord à l'offset nécessaire dans le fichier
     5013: 1155:		if(lseek(kv->descr_kv,offset+LG_EN_TETE_KV+longueur+4,SEEK_SET)==-1)
    #####: 1156:			return -1;
        -: 1157:		// enregistre la longueur de la valeur
     5013: 1158:		if(read_controle(kv->descr_kv,&longueur,4)==-1)
    #####: 1159:			return -1;
     5013: 1160:		val->len=longueur;		
     5013: 1161:		val->ptr=malloc(val->len);
        -: 1162:	}
        -: 1163:	else // val->len est le max d'octets que l'on peut lire
        -: 1164:	{
        -: 1165:		//compare val->len et la longueur de la valeur stockée
        -: 1166:		//se positionne d'abord à l'offset nécessaire dans le fichier
        1: 1167:		if(lseek(kv->descr_kv,offset+LG_EN_TETE_KV+longueur+4,SEEK_CUR)==-1) 
    #####: 1168:			return -1;		
        -: 1169:		// enregistre la longueur de la valeur
        1: 1170:		if(read_controle(kv->descr_kv,&longueur,4)==-1)
    #####: 1171:			return -1;
        -: 1172:		// affecte à val->len longueur si longueur<val->len
        1: 1173:		val->len= (longueur<val->len) ? longueur : val->len;	
        -: 1174:	}
        -: 1175:	// enregistre dans val->ptr le nb d'octets
     5014: 1176:	if(read_controle(kv->descr_kv,val->ptr,val->len)==-1) 
        -: 1177:	{	
    #####: 1178:		free(val->ptr);
    #####: 1179:		return -1;
        -: 1180:	}
     5014: 1181:	return 1;
        -: 1182:}
        -: 1183:
        -: 1184:// Remplit la clef
        -: 1185://retourne 1 si réussi, -1 sinon
     5012: 1186:int RemplissageClef(KV *kv,len_t offset, kv_datum *clef)
        -: 1187:{
     5012: 1188:	len_t longueur_a_allouer=0;
     5012: 1189:	len_t longueur=0;
        -: 1190:	//Vérification si val a déjà été alloué et si la longueur est déjà définie
     5012: 1191:	if(clef==NULL)
        -: 1192:	{
    #####: 1193:		clef=malloc(sizeof(struct kv_datum));
    #####: 1194:		clef->ptr=NULL;
        -: 1195:	}
     5012: 1196:	if(clef->ptr == NULL) // dans ce cas on cherche la longueur à allouer
        -: 1197:	{
     5012: 1198:		longueur_a_allouer=RechercheTailleClef(kv,offset);
     5012: 1199:		if(longueur_a_allouer==0) // erreur
    #####: 1200:			return -1;
     5012: 1201:		clef->ptr=malloc(longueur_a_allouer);
     5012: 1202:		clef->len=longueur_a_allouer;		
        -: 1203:	}
        -: 1204:	else // clef->len est le max d'octets que l'on peut lire
        -: 1205:	{
        -: 1206:		// recherche d'abord le max entre clef->len et la longueur de la valeur 
        -: 1207:		// stockéese positionne d'abord à l'offset nécessaire dans le fichier
    #####: 1208:		if(lseek(kv->descr_kv,offset+LG_EN_TETE_KV,SEEK_SET)==-1)
    #####: 1209:			return -1;
    #####: 1210:		if(read_controle(kv->descr_kv,&longueur,4)==-1)// longueur de la clef
    #####: 1211:			return -1;
        -: 1212:		// affecte à clef->len longueur si longueur<val->len
    #####: 1213:		clef->len= (longueur<clef->len) ? longueur : clef->len;
        -: 1214:	}
     5012: 1215:	if(read_controle(kv->descr_kv,clef->ptr,clef->len)==-1) 
        1: 1216:		return -1;
     5011: 1217:	return 1;
        -: 1218:}
        -: 1219:
        -: 1220:
        -: 1221://retourne le nr de bloc vide et l'initialise (suppose qu'il y a assez de place)
        -: 1222:// nb_bloc commence à 1 
        -: 1223://en-tête de bloc : bloc suivant(char)+nbloc suivant(int) nb emplacements (int)
        -: 1224:// MagicN + nb_blocs
        -: 1225:// retourne 1 si réussi -1 sinon
     3306: 1226:int Allouebloc(KV * kv)
        -: 1227:{
     3306: 1228:	kv->bloc=malloc(4096);
     3306: 1229:	int i=0;
     3306: 1230:	int vide=1;
     3306: 1231:	int numbloc=0;
        -: 1232:	int * nouvtab;
        -: 1233:	int j;
        -: 1234:	
  5066854: 1235:	while(vide==1)
        -: 1236:	{
  5060242: 1237:		if(i==kv->longueur_buf_bloc) // il faut agrandir le tableau
        -: 1238:		{
       32: 1239:			nouvtab=malloc(sizeof(int)*(kv->longueur_buf_bloc+100));
    50478: 1240:			for(j=0;j<kv->longueur_buf_bloc;j++) // copie le tableau
    50446: 1241:				nouvtab[j]=kv->tabbloc[j];
       32: 1242:			kv->longueur_buf_bloc+=100;
       32: 1243:			free(kv->tabbloc);
       32: 1244:			kv->tabbloc=nouvtab;
        -: 1245:			// remplit tabbloc (regarde dans blk si les blocs sont occupés )
       32: 1246:			if(remplit_bloc(j,kv)==-1)
    #####: 1247:				return -1;
        -: 1248:		}
  5060242: 1249:		if(kv->tabbloc[i]==0) // le bloc est vide
        -: 1250:		{
     3306: 1251:			numbloc=i;	
     3306: 1252:			kv->tabbloc[i]=1;
    33060: 1253:			for(i=0;i<9;i++)
    29754: 1254:				kv->bloc[i]=0;
     3306: 1255:			vide=0; // on a trouvé un bloc vide -> sort du while	
     3306: 1256:			kv->nb_blocs++;				
        -: 1257:		}
  5060242: 1258:		i++; // si pas trouvé regarde au bloc prochain
        -: 1259:	}
     3306: 1260:	return numbloc+1; // car la numérotation des blocs commence à 1
        -: 1261:}
        -: 1262:
        -: 1263:// écrit le numéro de bloc 
        -: 1264:// retourne 1 si réussi -1 sinon
     3303: 1265:int liaisonHBlk(KV * kv,int hache, int numbloc)
        -: 1266:{
        -: 1267:	// écrit dans .h numbloc
        -: 1268:	// se place
     3303: 1269:	if(lseek(kv->descr_h,LG_EN_TETE_H+hache*4,SEEK_SET)==-1)
    #####: 1270:		return -1;
     3303: 1271:	if(write_controle(kv->descr_h,&numbloc,4)==-1)
    #####: 1272:		return -1;
     3303: 1273:	return 1;	
        -: 1274:}
        -: 1275:
        -: 1276:// regarde s'il y a encore de la place pour une autre clef + valeur 
        -: 1277:// et regarde si des voisins sont libres + insérer cet nouvel espace dans dkv 
        -: 1278://emplacement_dkv : numéro de l'emplacement dans dkv (i)
     2979: 1279:void insertionFusionEspace(KV* kv,int emplacement_dkv)
        -: 1280:{
     2979: 1281:	int voisins=-1; // voisin suivant
     2979: 1282:	int voisinp=-1; // voisin précédent
        -: 1283:	//recherche l'emplacement suivant et précédent
     2979: 1284:	int nb_emplacementstmp=*(int*)kv->dkv;
     2979: 1285:	if(emplacement_dkv!=0&&access_lg_dkv(emplacement_dkv-1,kv)>0)
     1765: 1286:		voisinp=emplacement_dkv-1;
     2979: 1287:	if(emplacement_dkv+1!=*(int*)kv->dkv&&access_lg_dkv(emplacement_dkv+1,kv)>0)
      231: 1288:		voisins=emplacement_dkv+1;
     2979: 1289:	fusionVoisinsVidesSP( voisins,emplacement_dkv,voisinp , kv);
        -: 1290:	// si l'emplacement est le dernier le supprime (diminue le nb d'emplacments
     2979: 1291:	if(emplacement_dkv==*(int*)kv->dkv||emplacement_dkv+1==nb_emplacementstmp)
        -: 1292:	{	
        2: 1293:		kv->dkv=modif(kv->dkv,(*(int*)kv->dkv)-1,0); 
        2: 1294:		kv->remplissement_dkv-=8;
        -: 1295:	}
     2979: 1296:}
        -: 1297:
     2979: 1298:void fusionVoisinsVidesSP(int voisins, int emplacement_dkv, int voisinp, KV* kv)
        -: 1299:{
     2979: 1300:	if(voisinp!=-1) // si le voisin précédent est vide
        -: 1301:	{
        -: 1302:		// ajoute la taille de l'emplacement voisinp à emplacement_dkv
     3530: 1303:		kv->dkv=modif(kv->dkv, access_lg_dkv(emplacement_dkv,kv)
     3530: 1304:		  +access_lg_dkv(voisinp,kv),4+8*emplacement_dkv); 
        -: 1305:		// modifie l'offset et le met à celui de voisinp
     1765: 1306:		kv->dkv=modif(kv->dkv,access_offset_dkv(voisinp,kv),4+8*emplacement_dkv+4);
        -: 1307:		// libère voisinp
     1765: 1308:		decaledkv_arriere(kv,voisinp);
        -: 1309:		//diminue le nombre d'emplacements
     1765: 1310:		kv->dkv=modif(kv->dkv,*(int*)kv->dkv-1,0);
        -: 1311:		// décrémente le remplissement de dkv
     1765: 1312:		kv->remplissement_dkv-=8;
        -: 1313:		// supprime le dernier emplacement -> ftruncate dans close 
        -: 1314:	}
     2979: 1315:	if(voisins!=-1) // si le voisin suivant est vide
        -: 1316:	{
      231: 1317:		if(voisinp!=-1)
        -: 1318:		{
        9: 1319:			voisins--;
        9: 1320:			emplacement_dkv--;
        -: 1321:		}
        -: 1322:		// ajoute la taille de voisins à emplacement_dkv
      462: 1323:		kv->dkv=modif(kv->dkv,access_lg_dkv(emplacement_dkv,kv)+
      462: 1324:		  access_lg_dkv(voisins,kv),4+8*emplacement_dkv);		
        -: 1325:		// libère voisins
      231: 1326:		decaledkv_arriere(kv,voisins);
        -: 1327:		//diminue le nombre d'emplacements
      231: 1328:		kv->dkv=modif(kv->dkv,*(int*)kv->dkv-1,0);
        -: 1329:		// décrémente le remplissement de dkv
      231: 1330:		kv->remplissement_dkv-=8;
        -: 1331:		// supprime le dernier emplacement -> ftruncate dans close 
        -: 1332:	}
     2979: 1333:	return ;
        -: 1334:}
        -: 1335:
        -: 1336:// décalle tout dkv vers une position avant
     1996: 1337:void decaledkv_arriere(KV* kv,int emplacement_a_sup)
        -: 1338:{
        -: 1339:	int i;
     1996: 1340:	int nb_emplacements_dkv=*(int*)kv->dkv;
        -: 1341:	int tmp_lg;
        -: 1342:	int tmp_offset;
  6845035: 1343:	for(i=emplacement_a_sup;i<nb_emplacements_dkv-1;i++)
        -: 1344:	{
  6843039: 1345:		tmp_lg=access_lg_dkv(i+1,kv);
  6843039: 1346:		tmp_offset=access_offset_dkv(i+1,kv);
  6843039: 1347:		kv->dkv=modif(kv->dkv,tmp_lg,4+8*i);
  6843039: 1348:		kv->dkv=modif(kv->dkv,tmp_offset,4+8*i+4);
        -: 1349:	}
     1996: 1350:	return ;
        -: 1351:}
        -: 1352:
        -: 1353:
        -: 1354:// libère un emplacement identifié par son offset dans .dkv
     2979: 1355:void libereEmplacementdkv(len_t offset,KV* kv)
        -: 1356:{
        -: 1357:	int i;
     2979: 1358:	int nb_emplacements=*(int *)kv->dkv;
        -: 1359:	len_t offsetdkv;
  7762233: 1360:	for(i=0;i<nb_emplacements;i++)
        -: 1361:	{
        -: 1362:		// saute  nb_emplacements + i*(1+lg) + i*offset
  7762233: 1363:		offsetdkv=access_offset_dkv(i,kv);
  7762233: 1364:		if(offsetdkv==offset)
        -: 1365:		{
        -: 1366:			//on stock |lg| dans la longueur, or lg < 0 donc on stock -lg 
     2979: 1367:			kv->dkv=modif(kv->dkv,access_lg_dkv(i,kv)*(-1),4+8*i);
     2979: 1368:			insertionFusionEspace(kv,i);
        -: 1369:			// faut voir si l'emplacement se situe tout à droite (si c'est un
        -: 1370:			//emplacement vide à la fin de la base et s'il faut le supprimer)
     2979: 1371:			if(i==nb_emplacements)
        -: 1372:			{
        -: 1373:				// enlève un emplacement pour le libérer
    #####: 1374:				kv->dkv=modif(kv->dkv,nb_emplacements-1,0); 
    #####: 1375:				kv->remplissement_dkv-=8;
        -: 1376:			}
     2979: 1377:			return;
        -: 1378:		}
        -: 1379:	}
    #####: 1380:	return;
        -: 1381:}
        -: 1382:
        -: 1383:// libère un emplacement dans blk
        -: 1384://en-tête bloc:  bloc suivant(char)+nr bloc suivant(int) + nb emplacements (int)
        -: 1385:// bloc pere vaut 0 s'il y en a pas, le num du bloc père sinon
        -: 1386:// retourne 1 si réussi, -1 sinon
     2979: 1387:int libereEmplacementblk(int numbloc,len_t offset,KV *kv,int hache,int bloc_p)
        -: 1388:{
        -: 1389:	int i;
        -: 1390:	int nb_emplacements;
        -: 1391:	len_t offset_d_emplct;
        -: 1392:	// enregistre le nombre d'emplacements
     2979: 1393:	nb_emplacements=*(int*)(kv->bloc+5);
        -: 1394:	// enregistre l'offset du dernier emplacement
     2979: 1395:	offset_d_emplct=*(len_t*)(kv->bloc+4*(nb_emplacements-1)+LG_EN_TETE_BLOC);
        -: 1396:	// recherche d'abord l'emplacement à supprimer
   380748: 1397:	for(i=0;i<nb_emplacements;i++)
        -: 1398:	{
        -: 1399:		// Si on a trouvé le bon emplacement
   380748: 1400:		if(offset==*(len_t*)(kv->bloc+LG_EN_TETE_BLOC+i*4))
        -: 1401:		{// dans ce cas on met l'offset du dernier emplacement à la place i
        -: 1402:			//remplace l'offset contenu dans i par l'offset du dernier emplct
     2979: 1403:			kv->bloc=modif(kv->bloc,offset_d_emplct,LG_EN_TETE_BLOC+4*i);
        -: 1404:			// décrémente le nb d'emplacements
     2979: 1405:			kv->bloc=modif(kv->bloc,nb_emplacements-1,5);
     2979: 1406:			break; //emplacement trouvé donc sort de for
        -: 1407:		}
        -: 1408:	}
        -: 1409:	// indique que l'emplacement a pas été trouvé
     2979: 1410:	if(i==nb_emplacements||nb_emplacements==0)
        -: 1411:	{	
    #####: 1412:		free(kv->bloc);
        -: 1413:		//rééexcute la fonction avec le bloc prochain(c'est sûr qu'il y en a un)
        -: 1414:		//-> pour savoir s'il y en a un on le * -1 (car il faudra le lire)
    #####: 1415:		return libereEmplacementblk((-1)*(*(int*)(kv->bloc+1)),
        -: 1416:		  offset,kv,hache,numbloc); 
        -: 1417:	}
        -: 1418:	else
        -: 1419:	{
        -: 1420:		// dans ce cas on libère le bloc dans .h
     2979: 1421:		if(nb_emplacements-1==0&&bloc_p==0&&kv->bloc[0]==0)
        -: 1422:		{
      644: 1423:			if(supprimeblocdeh(kv,hache)==-1)
    #####: 1424:				return-1;
      644: 1425:			kv->nb_blocs--;
      644: 1426:			kv->tabbloc[numbloc-1]=0; // libère le bloc
        -: 1427:		}
        -: 1428:
        -: 1429:		// se place au bon endroit
     2979: 1430:		if(lseek(kv->descr_blk,LG_EN_TETE_BLK+(numbloc-1)*4096,SEEK_SET)==-1)
    #####: 1431:			return -1;
        -: 1432:		// écrit le bloc
     2979: 1433:		if(write_controle(kv->descr_blk,kv->bloc,
     2979: 1434:		LG_EN_TETE_BLOC+(nb_emplacements-1)*4)==-1)
        -: 1435:		{
    #####: 1436:			free(kv->bloc);
    #####: 1437:			return -1;
        -: 1438:		}
     2979: 1439:		free(kv->bloc);	
        -: 1440:	}
     2979: 1441:	return 1;
        -: 1442:}
        -: 1443:
        -: 1444:
        -: 1445:// Supprime la référence du bloc dans .h
        -: 1446:// retourne -1 en cas d'erreur sinon retourne 1
      644: 1447:int supprimeblocdeh(KV* kv, int hache)
        -: 1448:{
      644: 1449:	int i=0;
        -: 1450:	// libère l'emplacement dans la table de hachage
        -: 1451:	// se place au bon endroit
      644: 1452:	if(lseek(kv->descr_h,LG_EN_TETE_H+hache*4,SEEK_SET)==-1)
    #####: 1453:		return -1;
      644: 1454:	if(write_controle(kv->descr_h,&i,4)==-1)// écrit 0 au numéro de bloc
    #####: 1455:		return -1;
      644: 1456:	return 1;
        -: 1457:
        -: 1458:}
        -: 1459:
        -: 1460:
        -: 1461:
    14120: 1462:int (*choix_allocation(KV *kv))(KV * kv,const kv_datum* key, const kv_datum *val)
        -: 1463:{
    14120: 1464:	if(kv->methode_alloc==FIRST_FIT) return first_fit;
     5100: 1465:	if(kv->methode_alloc==BEST_FIT) return best_fit;
      100: 1466:	if(kv->methode_alloc==WORST_FIT) return worst_fit;
    #####: 1467:	return first_fit;
        -: 1468:}
        -: 1469:
        -: 1470:
        -: 1471:// création d'un nouvel emplacement à la fin de dkv
        -: 1472:// l'endroit de cet emplacement sera égal à nb_emplacements-1
        -: 1473:// en-tête dkv :MagicN+ nb_d'emplacements
    13852: 1474:void NouvEmplacementDkv(KV* kv, const kv_datum *key, const kv_datum *val)
        -: 1475:{
    13852: 1476:	int nb_emplacements=*(int*)kv->dkv; // nombre d'emplacements
    13852: 1477:	int taille_emplacement_necessaire = 4 + key->len + 4 + val->len;
        -: 1478:	len_t offset_emplacement;
    13852: 1479:	if(nb_emplacements==0) // au début, lors de la création
        -: 1480:	{
        4: 1481:		kv->dkv=modif(kv->dkv,1,0); // met le nb d'emplacements à 1
        4: 1482:		kv->dkv=modif(kv->dkv,taille_emplacement_necessaire,4);
        4: 1483:		offset_emplacement=0;
        4: 1484:		kv->dkv=modif(kv->dkv,offset_emplacement,8);
        4: 1485:		kv->remplissement_dkv+=8; // incrémente le remplissement de dkv
        4: 1486:		return ;
        -: 1487:	}
        -: 1488:	// ajoute un emplacement à la fin de dkv
    13848: 1489:	kv->dkv=modif(kv->dkv,nb_emplacements+1,0); //incrémente le nombre d'emplcts
    13848: 1490:	kv->remplissement_dkv+=8; // incrémente le remplissement de dkv
    13848: 1491:	if(kv->longueur_dkv<kv->remplissement_dkv) //le buffer n'est pas assez grand
        -: 1492:	{	
      108: 1493:		kv=dkv_aggrandissement(kv); // réalloue de la place : aggrandit le buffer
        -: 1494:	}
        -: 1495:	// initialise l'offset max à celui de la première valeur
    13848: 1496:	len_t offset_max=access_offset_dkv(nb_emplacements-1,kv);
        -: 1497:	// longueur de l'emplacement avec l'offset max
    13848: 1498:	int longueurmax=absolue(access_lg_dkv(nb_emplacements-1,kv));
    13848: 1499:	kv->dkv=modif(kv->dkv,offset_max+longueurmax,4+nb_emplacements*8+4);
    13848: 1500:	kv->dkv=modif(kv->dkv,taille_emplacement_necessaire,4+nb_emplacements*8);
    13848: 1501:	return ;
        -: 1502:}
        -: 1503:
        -: 1504:// fonction qui agrandit dkv
      108: 1505:KV* dkv_aggrandissement(KV * kv)
        -: 1506:{
      108: 1507:	kv->longueur_dkv+=1000;
      108: 1508:	kv->dkv=copie_tableau(kv->dkv,kv->remplissement_dkv);
      108: 1509:	return kv;	
        -: 1510:}
      108: 1511:unsigned char * copie_tableau(unsigned char * tableau, int longueur)
        -: 1512:{
        -: 1513:	int i;
      108: 1514:	unsigned char * tab= malloc(longueur+1000);
  3538404: 1515:	for(i=0;i<longueur;i++)
        -: 1516:	{
  3538296: 1517:		tab[i]=tableau[i];
        -: 1518:	}
      108: 1519:	free(tableau);
      108: 1520:	return tab;
        -: 1521:}
        -: 1522:
        -: 1523:// ATTENTION LA NUMEROTATION DES BLOCS COMMENCE A UN DONC FAUT ENLEVER 1 A NUMBLOC
        -: 1524://fonction qui fait le lien entre l'emplacement dans le bloc et kv
    14120: 1525:int lienBlkKv (int numbloc,KV * kv,len_t emplacement_kv)
        -: 1526:{
        -: 1527:
    14120: 1528:	int bloc=numbloc-1; // car la numérotation des blocs commence à 1
        -: 1529:	// placement au bon bloc 
        -: 1530:	// recherche emplacement dans bloc vide
    14120: 1531:	int emplacement_vide=*(int*)(kv->bloc+5);
        -: 1532:	//indique qu'on a changé de bloc (emplacement_vide contient le num du bloc)
    14120: 1533:	if(emplacement_vide==-1)
    #####: 1534:		return -1;
        -: 1535:
        -: 1536:	// se place au bon endroit dans .blk
    14120: 1537:	kv->bloc=modif(kv->bloc,emplacement_kv,LG_EN_TETE_BLOC+emplacement_vide*4);
        -: 1538:	
        -: 1539:	// incrémente le nb d'emplacements dans le bloc
    14120: 1540:	emplacement_vide++;	// incrémente nb emplacements
    14120: 1541:	kv->bloc=modif(kv->bloc,emplacement_vide,5);
        -: 1542:	// Pour finir écrit le bloc
    14120: 1543:	if(lseek(kv->descr_blk,LG_EN_TETE_BLK+4096*bloc,SEEK_SET)==-1)
    #####: 1544:		return -1;
    14120: 1545:	if(write_controle(kv->descr_blk,kv->bloc,LG_EN_TETE_BLOC+
    14120: 1546:	 4*(*(int*)(kv->bloc+5)))==-1)
    #####: 1547:		return -1;
    14120: 1548:	free(kv->bloc);
        -: 1549:	
    14120: 1550:	return 1;
        -: 1551:}
        -: 1552:
        -: 1553:// met l'emplacement en tant que place occupée dans dkv
    14120: 1554:KV* SetOccupeDkv(KV* kv,int emplacement_dkv)
        -: 1555:{
    14120: 1556:	kv->dkv=modif(kv->dkv,access_lg_dkv(emplacement_dkv,kv)
    14120: 1557:	*(-1),LG_EN_TETE_DKV+emplacement_dkv*8-1); // on a pas prit le magic number
    14120: 1558:	return kv;
        -: 1559:}
        -: 1560:
        -: 1561:
        -: 1562:// voit s'il y a encore de la place pour une autre clef + valeur 
        -: 1563:// puis insérer cet nouvel espace dans dkv
        -: 1564:// emplacement_dkv : numéro de l'emplacement dans dkv (i)
    14120: 1565:void insertionNewEspace(KV* kv,int emp_dkv,const kv_datum*key,const kv_datum*val)
        -: 1566:{
    14120: 1567:	int nbemplacements=*(int*)kv->dkv;
    14120: 1568:	len_t taille_couple=4+key->len + 4 + val->len;
    14120: 1569:	int octets_restants=(-1)*access_lg_dkv(emp_dkv,kv)-(taille_couple);
        -: 1570:	//regarde si place pour une autre clef
    14120: 1571:	if(octets_restants-10>0) // s'il reste plus de 10 octets (2int + 2 octets)
        -: 1572:	{
        -: 1573:		// diminue la longueur de emplacement_kv à la taille du couple
       18: 1574:		kv->dkv=modif(kv->dkv,taille_couple*(-1),4+8*emp_dkv);
        -: 1575:	}
        -: 1576:	else // sinon retourne kv
    14102: 1577:		return ;
        -: 1578:	
       18: 1579:	if(emp_dkv==nbemplacements-1) 
    #####: 1580:		return ;
        -: 1581:	//si n'a pas pu fusionner avec le voisin précédent, fait un nouvel emplct
       18: 1582:	creationNewVoisin(kv,octets_restants,emp_dkv+1,taille_couple);
       18: 1583:	return ;
        -: 1584:}
        -: 1585:
        -: 1586:
        -: 1587:// créé un nouvel emplacement
       18: 1588:void creationNewVoisin(KV* kv,int octets_restants,int empl_dkv,len_t t_couple)
        -: 1589:{
        -: 1590:	// décalle d'abord tout dkv vers une position à l'avant
       18: 1591:	decaledkv_avant(kv,empl_dkv);
        -: 1592:	//créé le nouvel emplacement
        -: 1593:	// met la longueur à octets_restants
       18: 1594:	kv->dkv=modif(kv->dkv,octets_restants,4+(empl_dkv)*8);
       18: 1595:	kv->dkv=modif(kv->dkv,access_offset_dkv(empl_dkv-1,kv)+
       18: 1596:	  t_couple,4+(empl_dkv)*8+4);
       18: 1597:	return ;
        -: 1598:}
        -: 1599:	
        -: 1600:// décalle tout dkv vers une position avant
       18: 1601:void decaledkv_avant(KV* kv,int emplacement_a_decal)
        -: 1602:{
       18: 1603:	int i=emplacement_a_decal;
       18: 1604:	int nb_emplacements_dkv=*(int*)kv->dkv;
        -: 1605:	int tmp_lg;
        -: 1606:	int tmp_offset;
        -: 1607:	int tmp_lg_suiv;
        -: 1608:	int tmp_offset_suiv;
       18: 1609:	int nb_emplacements=*(int*)kv->dkv +1;
        -: 1610:	// incrémente le nombre d'emplacements
       18: 1611:	kv->dkv=modif(kv->dkv,nb_emplacements,0);
        -: 1612:	// incrémente le remplissement de dkv
       18: 1613:	kv->remplissement_dkv+=8;
        -: 1614:	// regarde si toujours assez de place
       18: 1615:	if(kv->longueur_dkv<kv->remplissement_dkv)//le buffer n'est plus assez grand
    #####: 1616:		kv=dkv_aggrandissement(kv);
        -: 1617:		
       18: 1618:	tmp_lg_suiv=access_lg_dkv(i+1,kv);
       18: 1619:	tmp_offset_suiv=access_offset_dkv(i+1,kv);
       18: 1620:	tmp_lg=access_lg_dkv(i,kv);
       18: 1621:	tmp_offset=access_offset_dkv(i,kv);
       18: 1622:	kv->dkv=modif(kv->dkv,tmp_lg,4+8*(i+1));
       18: 1623:	kv->dkv=modif(kv->dkv,tmp_offset,4+8*(i+1)+4);
    26759: 1624:	for(i=emplacement_a_decal+1;i<nb_emplacements_dkv;i++)
        -: 1625:	{
    26741: 1626:		tmp_lg=tmp_lg_suiv;
    26741: 1627:		tmp_offset=tmp_offset_suiv;
    26741: 1628:		tmp_lg_suiv=access_lg_dkv(i+1,kv);
    26741: 1629:		tmp_offset_suiv=access_offset_dkv(i+1,kv);
    26741: 1630:		kv->dkv=modif(kv->dkv,tmp_lg,4+8*(i+1));
    26741: 1631:		kv->dkv=modif(kv->dkv,tmp_offset,4+8*(i+1)+4);
        -: 1632:		
        -: 1633:	}
       18: 1634:	return;
        -: 1635:}
        -: 1636:
        -: 1637:// tronque kv
        7: 1638:int truncate_kv(KV* kv)
        -: 1639:{
        7: 1640:	if(strcmp(kv->mode,"r")==0) // pas besoin de tronquer vu que rien n'a changé
        1: 1641:		return 1;
        6: 1642:	len_t offset_max=0;
        6: 1643:	len_t longueur_max=0;
        -: 1644:	int i;
        6: 1645:	int nb_emplacements_dkv=0;
        -: 1646:	// recherche le plus grand emplacement (offset)
        6: 1647:	nb_emplacements_dkv=*(int*)kv->dkv;
    26728: 1648:	for(i=0;i<nb_emplacements_dkv;i++)
        -: 1649:	{
    26722: 1650:		if(offset_max <= access_offset_dkv(i,kv))
        -: 1651:		{
    26722: 1652:			offset_max=access_offset_dkv(i,kv);
    26722: 1653:			longueur_max=absolue(access_lg_dkv(i,kv));
        -: 1654:		}
        -: 1655:	}
        -: 1656:	// on tronque à offset_max+longueur_max + LG_EN_TETE_KV
        6: 1657:	if(ftruncate(kv->descr_kv,offset_max+longueur_max+LG_EN_TETE_KV)==-1)
    #####: 1658:		return -1;
        6: 1659:	return 1;	
        -: 1660:	
        -: 1661:}
